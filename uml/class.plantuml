@startuml
allowmixing

abstract User {
  + Id id
  + String name
  + String description
}

class Applicant

class Employer

class UserManager {
  + User create(name: String, desc: String)
  + void editName(userId: Id, name: String)
  + void editDescription(userId: Id, desc: String)
  + void delete(userId: Id)
  + User getUser(userId: Id)
}

class VacancyManager {
  + void createVacancy(name: String, desc: String, tags: List<Tag>)
  + void editVacancy(id: Id, name: String, desc: String, tags: List<Tag>)
  + void deleteVacancy(id: Id)
  + List<Vacancy> getVacancies(employerId: Id)
}

class ResponseManager {
  + void respond(vacancyId: Id)
  + List<Id> getRespondees(vacancyId: Id)
}

class Vacancy {
  + Id id
  + String name
  + String description
  + bool isClosed
}

class Tag {
  + String name
}

class SearchEngine {
  List<Id> searchEmplyers(query: String)
  List<Id> searchVacancies(query: String)
  void applyTagFilter(tags: List<Tag>)
  void applyEmployerFilter(employerIds: List<Id>)
}

package Database <<Database>> {
  interface Repository<T> {
    + T get(id: Id)
    + Id create(thing: T)
    + bool update(id: Id, newState: T)
    + bool delete(id: Id)
  }
}

VacancyRepository --|> Repository:<T::Vacancy>
UserRepository --|> Repository:<T::User>

UserManager --> UserRepository
VacancyManager --> VacancyRepository
SearchEngine --> VacancyRepository
SearchEngine --> UserRepository
ResponseManager --> VacancyRepository

Employer -|> User
Applicant -|> User

User <--> UserManager

Employer --> VacancyManager
Tag -o Vacancy

Applicant --> SearchEngine

VacancyManager -.-> Vacancy

SearchEngine -.-> Vacancy

Applicant --> ResponseManager
Employer --> ResponseManager

@enduml
